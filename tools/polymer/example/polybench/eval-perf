#!/bin/bash
# Evaluate the performance difference between Pluto and Polymer.

PLUTO_OPTIONS="--noparallel --noprevector --nounrolljam"
CLANG_OPTIONS="-fno-vectorize"
SKIP_EXECUTE="false"
SKIP_CODEGEN="false"

while getopts ":hgspvf:" opt; do 
  case "${opt}" in 
    h ) 
      echo ""
      echo "    Performance evaluator for Pluto and Polymer."
      echo ""
      echo "Usage: "
      echo "    -h                  Display this help message"
      echo "    -s                  Skip the actual run"
      echo "    -g                  Skip the Pluto and Polymer codegen"
      echo "    -v                  Enable vectorization by Clang"
      echo "    -p                  Enable parallelization"
      echo "    -f <target>         Evaluate the <target> file"
      exit 0
      ;;
    f )
      TARGET="${OPTARG}"
      ;;
    g )
      SKIP_CODEGEN="true"
      ;;
    s )
      SKIP_EXECUTE="true"
      ;;
    p )
      PLUTO_OPTIONS=""
      ;;
    v )
      CLANG_OPTIONS=""
      ;;
    \? )
      echo "Invalid Option: -$OPTARG" 1>&2
      exit 1
      ;;
  esac
done
shift $((OPTIND -1))

TEST_CASE="$(cd "$(dirname "${TARGET}")"; pwd)/$(basename "${TARGET}")"
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd)"
UTILITIES_DIR="${DIR}/utilities"
PLUTO_DIR="${DIR}/../../pluto"
LLVM_DIR="${DIR}/../../llvm"
POLYMER_DIR="${DIR}/../../"

export PATH="${PATH}:${PLUTO_DIR}"
export PATH="${LLVM_DIR}/build/bin:${PATH}"
export PATH="${POLYMER_DIR}/build/bin:${PATH}"

# Compile and run the source file by Pluto.
# Args:
#    SRC_FILE           File to be compiled and run
# Outputs:
#    PLUTO_EXE_FILE     Path to the Pluto-compiled executable
#    PLUTO_RUN_TIME     Total run time of the Pluto-compiled executable
# Globals:
#    SKIP_EXECUTE       Skip the execution
#    SKIP_CODEGEN       Skip the codegen
#    UTILITIES_DIR      Where the polybench utilities placed
function run_pluto() 
{
  local SRC_FILE="$1"
  local __RESULT_PLUTO_EXE_FILE="$2"
  local __RESULT_PLUTO_RUN_TIME="$3"
  local SRC_DIR="$(dirname "${SRC_FILE}")"
  local PLUTO_SRC_FILE="${SRC_FILE%.c}.pluto.c"
  local PLUTO_LLVM_IR_FILE="${SRC_FILE%.c}.pluto.ll"
  local PLUTO_EXE_FILE="${SRC_FILE%.c}.pluto.exe"
  local POLYCC_LOG="polycc_$(date "+%Y%m%d-%H%M%S").log"
  local POLYBENCH_SRC_FILE="${UTILITIES_DIR}/polybench.c"

  cd "${SRC_DIR}" >/dev/null 2>&1

  # Apply Pluto
  if [ "${SKIP_CODEGEN}" = "false" ]; then
    polycc "${PLUTO_OPTIONS}" "${SRC_FILE}" 2>&1 >"${POLYCC_LOG}"
  fi
  if [ ! -f "${PLUTO_SRC_FILE}" ]; then
    echo "Expected Pluto output ${PLUTO_SRC_FILE} does not exist."
    exit 1
  fi

  # Compile Pluto generated code
  clang "${PLUTO_SRC_FILE}" -O3 "${CLANG_OPTIONS}" -o "${PLUTO_LLVM_IR_FILE}" -S -emit-llvm -I "${UTILITIES_DIR}" \
    -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET  
  clang "${PLUTO_LLVM_IR_FILE}" "${POLYBENCH_SRC_FILE}" -o "${PLUTO_EXE_FILE}" -lm \
    -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET

  # Run the Pluto-compiled executable
  if [ "${SKIP_EXECUTE}" = "false" ]; then
    eval $__RESULT_PLUTO_RUN_TIME="$("${PLUTO_EXE_FILE}")"
  fi
  eval $__RESULT_PLUTO_EXE_FILE="${PLUTO_EXE_FILE}"

  cd - >/dev/null 2>&1
}

# Compile and run Polymer generated MLIR code.
# Args:
#    SRC_FILE             File to be compiled and run
# Outputs:
#    POLYMER_EXE_FILE     Path to the Polymer-compiled executable
#    POLYMER_RUN_TIME     Total run time of the Polymer-compiled executable
# Globals:
#    SKIP_EXECUTE       Skip the execution
#    SKIP_CODEGEN       Skip the codegen
#    UTILITIES_DIR      Where the polybench utilities placed
function run_polymer()
{
  local SRC_FILE="$1"
  local __RESULT_POLYMER_EXE_FILE="$2"
  local __RESULT_POLYMER_RUN_TIME="$3"
  local POLYMER_SRC_FILE="${SRC_FILE%.mlir}.polymer.mlir"
  local POLYMER_LLVM_IR_FILE="${SRC_FILE%.mlir}.polymer.ll"
  local POLYMER_CLAST_FILE="${SRC_FILE%.mlir}.polymer.cloog"
  local POLYMER_EXE_FILE="${SRC_FILE%.mlir}.polymer.exe"
  local POLYBENCH_SRC_FILE="${UTILITIES_DIR}/polybench.c"

  local SRC_DIR="$(dirname "${SRC_FILE}")"

  if [ "${SKIP_CODEGEN}" = "false" ]; then
    # Generate Polymer optimized MLIR code.
    polymer-opt -reg2mem -extract-scop-stmt -pluto-opt="dump-clast-after-pluto=${POLYMER_CLAST_FILE}" -canonicalize \
      "${SRC_FILE}" 2>/dev/null > "${POLYMER_SRC_FILE}"
    # Compile Polymer generated MLIR code.
    mlir-opt -lower-affine -convert-scf-to-std -cse -canonicalize -convert-std-to-llvm "${POLYMER_SRC_FILE}" |\
      mlir-translate -mlir-to-llvmir > "${POLYMER_LLVM_IR_FILE}"
  fi
  clang "${POLYMER_LLVM_IR_FILE}" "${POLYBENCH_SRC_FILE}" -o "${POLYMER_EXE_FILE}" -I "${UTILITIES_DIR}" -lm \
    -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET 

  # Run the Polymer-compiled executable
  if [ "${SKIP_EXECUTE}" = "false" ]; then
    eval $__RESULT_POLYMER_RUN_TIME="$("${POLYMER_EXE_FILE}")"
  fi
  eval $__RESULT_POLYMER_EXE_FILE="${POLYMER_EXE_FILE}"
}

if [ -f "${TEST_CASE}" ]; then
  run_pluto "${TEST_CASE}" PLUTO_EXE_FILE PLUTO_RUN_TIME
  echo "Pluto run time:   ${PLUTO_RUN_TIME}" 

  run_polymer "${TEST_CASE%.c}.mlir" POLYMER_EXE_FILE POLYMER_RUN_TIME
  echo "Polymer run time: ${POLYMER_RUN_TIME}" 
fi
